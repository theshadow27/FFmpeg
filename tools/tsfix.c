#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#define SIZE 5000*1000
uint8_t buf[SIZE];

// Holds PID counters invalid=>0, 1000=>1, 8191 => 2, 0=>3, 32=>4
int cctr[5] = {0, 1, 1, 1, 1};
int nulldist[1024];
int nulllen[1024];

typedef struct Header {
    // Fixed (almost, as data changes in the cc field)
    uint8_t data[188];
    uint8_t mask[188];
    double threshold;
    int type; // PID invalid=>0, 1000=>1, 8191 => 2, 0=>3, 32=>4,
    
    
    // Set in init()
    int possible; // total possible score
    int len;
    // Variable
    int freqs[188*8];
    int matched;
    
} Header;

//Shanuson on 05/12/2014 07:06 PM
//With some different flagbits we end with the following TS-headers:
//with the 4 different counters W,X,Y,Z
//  PID 0      :  47 40 00 1W
//  PID 32     :  47 40 20 1X
//  PID 1000_1 :  47 03 E8 1Y
//          _2 :  47 03 E8 3Y 
//          _3 :  47 43 E8 3Y
//  PID 8191   :  47 1F FF 1Z 

/* 
   This defines the matchers for the different TS header types 
   Note here that any 0x00 masks MUST have non-zero data, 
   since {0x00, 0x00} is taken as the termination condition. 
*/

Header headers[] = {
    {   // PID 1000_1 
        { 0x47, 0x03, 0xE8, 0x10 },
        { 0xFF, 0xFF, 0xFF, 0xFF },
        0.80,
        1
    },
    {   // PID 1000_2
        { 0x47, 0x03, 0xE8, 0x30,    0xFF, 0x00, 0x03, 0x6D, 0x72, 0xF4, 0x6E, 0x11, 0xFF, 0x20, 0x10, 0xF2, 0xFF, 0x08, 0x08, 0xFF, 0xFF, 0x01, 0xFF, 0x02, 0xFF} ,
        { 0xFF, 0xFF, 0xFF, 0xFF,    0x00, 0xFF, 0x03, 0x6D, 0x72, 0xF4, 0x6E, 0x11, 0x00, 0x20, 0x10, 0xF2, 0x00, 0x08, 0x08, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00},
        0.80,
        1
    },
    {    //PID 1000_3, form 1  
        { 0x47, 0x43, 0xE8, 0x30,   0x07, 0x10, 0x01, 0x2D, 0xF1, 0xBB, 0x7E, 0x01, 0x00, 0x00, 0x01, 0xE0, 0x00, 0xC0, 0x81, 0x80, 0x07, 0x21, 0x01, 0x6F, 0x78, 0xCD, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xB0, 0x03, 0x00, 0x00, 0x01, 0xB5, 0x0D, 0x0F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0xC4, 0x8D, 0xC0, 0x00, 0x46, 0x56, 0xC0, 0x1E, 0xC0, 0x01, 0xF6, 0xEA, 0x9A, 0xFC, 0x7C, 0x2E, 0xEE, 0x2C, 0x08, 0x78, 0x28, 0xC7, 0x00, 0x00, 0x01, 0xB2, 0x65, 0x6D, 0x34, 0x76, 0x20, 0x34, 0x2E, 0x33, 0x2E, 0x30, 0x2E, 0x30, 0x00, 0xC3, 0xFF, 0x00, 0x00, 0x01, 0xB6, 0x18},
        { 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0x00, 0x01, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0},
         0.80, // threshold
         1,    // type
    }, 
    {   // PID 1000_3, form 2
        { 0x47, 0x43, 0xE8, 0x30,   0x07, 0x10, 0x01, 0x33, 0x42, 0x77, 0x7E, 0x01, 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x81, 0x80, 0x07, 0x21, 0x01, 0x99, 0xBB, 0xBD, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xB6, 0x40},
        { 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0x00, 0x01, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0},
        0.80,
        1
    }, 
    { // null packet
        {0x47, 0x1F, 0xFF, 0x1F,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
        {0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
        0.80,
        2
    },
    {   // from gospacex's fix_4740001x_packets  (PID 0)
        { 0x47, 0x40, 0x00, 0x10,   0x00, 0x00, 0xB0, 0x11, 0x00, 0x00, 0xC1, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0x00, 0x01, 0xE0, 0x20, 0xD3, 0x6A, 0xF0, 0xAC,      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },  
        { 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
        0.90,
        3
    },
    {  // from gospacex's fix_4740201x_packets (PID 32)
        { 0x47, 0x40, 0x20, 0x10,   0x00, 0x02, 0xb0, 0x1f, 0x00, 0x01, 0xC1, 0x00, 0x00, 0xe3, 0xe8, 0xf0, 0x00, 0x10, 0xE3, 0xE8, 0xF0, 0x03, 0x1B, 0x01, 0xF5, 0x80, 0xE3, 0xE9, 0xF0, 0x00, 0x81, 0xE3, 0xF3, 0xF0, 0x00, 0x3F,       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
        { 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},  
        0.80,
        4
    },
    {   // just fix the 47, not sure of rest of data
        {0x47, 0x03, 0xE8, 0x10},
        {0xFF, 0x03, 0xFF, 0x1F},
        0,  // threshold
        1,  // type
    }
};
// there are only 5 real templates, the 6th is the fallback
#define NUM_TEMPLATES 5

//         {0x47, 0x03, 0xE8, 0x13},
//         {0xFF, 0xFF, 0xFF, 0xF0},
#define GETBIT(p, i) (  (  (p)[(i)>>3] >> (((~i)&7))  ) & 1)
#define PUTBIT(p, i, v)  (((uint8_t*)p)[(i)>>3] = ((v) ? ((p)[(i)>>3] | (1<<(((~(i))&7)))) : ((p)[(i)>>3] &~ (1<<(((~(i))&7))))))

uint8_t _popc8lut_[] = {
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};

#define popc8(x) (_popc8lut_[(uint8_t)x])

#define DUMPBUFF(b, n)  for(int _j=0; _j<n; _j++) fprintf(stderr, "%02X ", ((uint8_t*)b)[_j]); fprintf(stderr, "\n");
#define DUMPBUFF2(b, n)  fprintf(stderr, "{"); for(int _j=0; _j<n; _j++) fprintf(stderr, "0x%02X, ", ((uint8_t*)b)[_j]); fprintf(stderr, "},\n");

void init(){
    int i, j, k;
    // precompute possible scores
    for(j = 0; j < NUM_TEMPLATES; j++){
        for(k = 1; k < 188; k++){
            if(!(headers[j].data[k] | headers[j].mask[k])) break;
            headers[j].possible += popc8(headers[j].mask[k]);
        }
        headers[j].len = k;
    } 
    headers[NUM_TEMPLATES].len = 4;
}


int main(int argc, char **argv) {
    init();
    
    Header* h;
    
    // stats
    int packetnum = 0, cc_fix = 0, pid_fix = 0, fourseven_fix = 0; 
    int in_pid, in_cc, in_is_start, in_afc; 
    int sinceLastNull = 0, nullString =0;
    
    int i=0, j, k, len, pid, afc, is_start, cc;
    int in_video = 0;
    
    
    // read in input
    while(!feof(stdin)) buf[i++] = getchar();
    len = i-1;

    for (i=0; i<len; i+=188, packetnum++) {  // for each possible packet
    
        if(buf[i] != 0x47) fourseven_fix++;
    
#if 0
        fprintf(stderr, "%08X ", packetnum);
        for(j=0; j<188; j++) fprintf(stderr, "%02X ", buf[i+j]);
        fprintf(stderr, "\n");
#endif

        // Compute score for each template
        double max_prob = 0; int max_j = NUM_TEMPLATES;
        
        
        //for(j=0; j<188; j++) fprintf(stderr, "%02X", buf[i+j]);
        
        // set the continuity counter in each template correctly 
        for(j=0, h=headers; j <= NUM_TEMPLATES; j++, h++)      
            h->data[3] = (h->data[3] & 0xf0) | (cctr[h->type] & 0x0f);
        
        
        fprintf(stderr, "STAT %08X \n", packetnum);
        for(j = 0; j < NUM_TEMPLATES; j++) { 
            h = &headers[j];
            
            int score = 0;
            for (k=1; k < 188 ; k++) {
                if (h->mask[k]) // count bits that are the same 
                    score += popc8(   h->mask[k] &~ (buf[i+k] ^ h->data[k])   ); // xnor
            }
            
            double prob = score/(double)(h->possible);
            //fprintf(stderr, "[%3d/%-3d -> %0.6f] ", score, h->possible, prob);
            //DUMPBUFF(h->data, 8); 
            
            if(prob > max_prob && prob > h->threshold){
                max_prob = prob;
                max_j = j;
            }
        }
        
        if(max_j == NUM_TEMPLATES){
            fprintf(stderr, " (NO_MATCH) \n");
        } else {
            fprintf(stderr, "=> %d \n", max_j);
        }

        

        in_video = 0;
        in_is_start = buf[i+1] & 0x40;
        in_pid = ((buf[i+1]<<8) + buf[i+2]) & 0x1FFF;
        in_afc = (buf[i+3] >> 4) & 3;
        in_cc = buf[i+3] & 0xf;
        
          
        h = &headers[max_j];
        
        // Count Frequencies
        for(k = 0; k < 188*8; k++)
            h->freqs[k]+=GETBIT(buf, k + 8*i);
        h->matched++;
        
        
        //DUMPBUFF( buf+i, 16); 
        for(k=0; k < 188; k++) 

            if (h->mask[k]) // flip bits that are not masked
                buf[i+k] = (buf[i+k] &~h->mask[k]) | (h->data[k] & h->mask[k]); 
        
         fprintf(stderr, "MATCHER %4d: ", max_j); DUMPBUFF(buf + i, 16);
         cctr[h->type]++;

              //  in_video = h.type == 1;
//         }


        is_start = buf[i+1] & 0x40;
        pid = ((buf[i+1]<<8) + buf[i+2]) & 0x1FFF;
        afc = (buf[i+3] >> 4) & 3;
        cc = buf[i+3] & 0xf;
        
        if(in_pid != pid){
            fprintf(stderr, "PID %d -> %d\n", in_pid, pid);
            pid_fix++;
        }
        if(in_cc != cc){
            fprintf(stderr, "CC[%d] %d -> %d\n", pid, in_cc, cc);
            cc_fix++;
        }
        
        
        if (pid == 1000)
            in_video = 1;
       
        if(pid == 8191){
            nulldist[sinceLastNull]++;
            sinceLastNull = 0;
            nullString ++;
        } else {
            if(nullString){
               nulllen[nullString]++;
               nullString = 0;
            }
            sinceLastNull++;
        }
       
        if (buf[i] != 0x47) {
            fprintf(stderr, "Fixing 0x%02X->0x47\n", buf[i]);
            buf[i] = 0x47;
        }

//         //1008, 4072 1001 1011
//         if (in_video && pid != 0 && pid != 8191 && pid != 1000 && pid != 32 && pid != 64) {
//             //fprintf(stderr, "PID %d -> 1000\n", pid);
//             //pid = 1000; // UNCOMMENT ME AFTER PID COUNTING
//         }
        
        
        if (pid == 1000 && !(afc&1)) {
            fprintf(stderr, "AFC %d -> %d\n", afc, afc|1);
            afc |= 1;
        }
        
        if (is_start && pid == 1000) {
            int j;
            for (j=0; j<188-3; j++) {
                if (buf[i+j] == 0 && buf[i+j+1] == 0 && buf[i+j+2] == 1)
                    break;
            }
            if (j == 188-3) {
                fprintf(stderr, "discarding is start\n");
                is_start = 0;
            }
        }
//without 0x47 fixing 3372
//without pid=1000 3356
//without afc|=1 3624
//ref 3728
//without is_start=0 2532

        buf[i+1] = (buf[i+1] & ~0x5F) + (pid>>8) + is_start;
        buf[i+2] = pid;
        
        buf[i+3] = (buf[i+3] & ~0x30) + (afc << 4);
        //buf[i+3] = (buf[i+3] & ~0x3f) + (afc << 4) + cc;
    }
    for (i=0; i<len; i++)
        putchar(buf[i]);



    // Print gathered statistics, and 
    fprintf(stderr, "PID FIX    %d\n", pid_fix);
    fprintf(stderr, "CC FIX     %d\n", cc_fix);
    fprintf(stderr, "47 FIX     %d\n", fourseven_fix);
    
    fprintf(stderr, "PID 0      %d\n", cctr[3]);
    fprintf(stderr, "PID 32     %d\n", cctr[4]);
    fprintf(stderr, "PID 1000   %d\n", cctr[1]);
    fprintf(stderr, "PID 8191   %d\n", cctr[2]);
    fprintf(stderr, "Counted %d/%d PIDs\n", cctr[1]+cctr[2]+cctr[3]+cctr[4], packetnum);
    
    double prob;
    double setp = 0.15;
    int mask, data;
    for(j = 0, h=headers; j <= NUM_TEMPLATES; j++, h++){
    fprintf(stderr, "Matcher %d matched %d times\n", j, h->matched);
        for(k=0; k <188*8; k++){
            prob = (h->freqs[k])/((double)(h->matched));
            if(1.0 - prob < setp){
                data = 1;
                mask = 1;
            } else if(prob < setp){
                data = 0;
                mask = 1;
            } else {
                data = 1;
                mask = 0;
            }
            PUTBIT(h->data, k, data);
            PUTBIT(h->mask, k, mask);
        }
        for(k = 188; k > 0; k--) if(h->mask[k-1]) break; 
        
         fprintf(stderr, "data ");
        DUMPBUFF2(h->data, k);
        fprintf(stderr, "mask ");
        DUMPBUFF2(h->mask, k);
        
    }
    
    
    for(k= 0; k < 256; k++)
       // if(nulldist[k])
            fprintf(stderr, "SINCENULL, %d, %d\n", k, nulldist[k]);
        
    for(k= 0; k < 64; k++)
        //if(nulllen[k])
            fprintf(stderr, "NULLLEN, %d, %d\n", k, nulllen[k]);
        
    
    return 0;
}
