#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
 
#define SIZE 5000*1000
uint8_t buf[SIZE];
 
// continuity counter
uint8_t cctr[2048];
 
typedef struct Header {
    uint8_t data[188];
    uint8_t mask[188];
    double threshold;
    int flags;
} Header;
 
// Note here that any 0x00 masks MUST have non-zero data, since {0x00, 0x00} is taken as the termination condition.
Header headers[] = {
    {    // video packet
        { 0x47, 0x43, 0xE8, 0x30,   0x07, 0x10, 0x01, 0x2D, 0xF1, 0xBB, 0x7E, 0x01, 0x00, 0x00, 0x01, 0xE0, 0x00, 0xC0, 0x81, 0x80, 0x07, 0x21, 0x01, 0x6F, 0x78, 0xCD, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xB0, 0x03, 0x00, 0x00, 0x01, 0xB5, 0x0D, 0x0F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0xC4, 0x8D, 0xC0, 0x00, 0x46, 0x56, 0xC0, 0x1E, 0xC0, 0x01, 0xF6, 0xEA, 0x9A, 0xFC, 0x7C, 0x2E, 0xEE, 0x2C, 0x08, 0x78, 0x28, 0xC7, 0x00, 0x00, 0x01, 0xB2, 0x65, 0x6D, 0x34, 0x76, 0x20, 0x34, 0x2E, 0x33, 0x2E, 0x30, 0x2E, 0x30, 0x00, 0xC3, 0xFF, 0x00, 0x00, 0x01, 0xB6, 0x18},
        { 0xFF, 0xFF, 0xFF, 0xF0,   0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0x00, 0x01, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0},
         0.30,
         1
    },
    {  // video packet2
        { 0x47, 0x43, 0xE8, 0x32,   0x07, 0x10, 0x01, 0x33, 0x42, 0x77, 0x7E, 0x01, 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x81, 0x80, 0x07, 0x21, 0x01, 0x99, 0xBB, 0xBD, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xB6, 0x40},
        { 0xFF, 0xFF, 0xFF, 0xF0,   0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0x00, 0x01, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0},
        0.4,
        1
    },
    { // null packet
        { 0x47, 0x1F, 0xFF, 0x10,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
        { 0xFF, 0xFF, 0xFF, 0xF0,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
        0.70,
        0
    },
    {   // from gospacex's fix_4740001x_packets
        { 0x47, 0x40, 0x00, 0x10,   0x00, 0x00, 0xB0, 0x11, 0x00, 0x00, 0xC1, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0x00, 0x01, 0xE0, 0x20, 0xD3, 0x6A, 0xF0, 0xAC },  
        { 0xFF, 0xFF, 0xFF, 0xF0,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
        0.90,
        0
    },
    {  // from gospacex's fix_
        { 0x47, 0x40, 0x20, 0x10,   0x00, 0x02, 0xb0, 0x1f, 0x00, 0x01, 0xC1, 0x00, 0x00, 0xe3, 0xe8, 0xf0, 0x00, 0x10, 0xE3, 0xE8, 0xF0, 0x03, 0x1B, 0x01, 0xF5, 0x80, 0xE3, 0xE9, 0xF0, 0x00, 0x81, 0xE3, 0xF3, 0xF0, 0x00, 0x3F},
        { 0xFF, 0xFF, 0xFF, 0xF0,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},  
    },
    {   // just add 47
        {0x47},
        {0xFF},
        0,
    }
};
 
//         {0x47, 0x03, 0xE8, 0x13},
//         {0xFF, 0xFF, 0xFF, 0xF0},
#define GETBIT(p, i) (((p)[(i)>>3] << (((i)&7))>>7)&1)
#define PUTBIT(p, i, v) (p)[(i)>>3] = ((p)[(i)>>3] | ((v)<<7>>((i)&7))) & (((((v)<<7) + 0xFF7F) >>((i)&7)))
 
 
 
 
uint8_t _popc8lut_[] = {
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};
 
#define popc8(x) (_popc8lut_[(uint8_t)x])
 
 
 
int main(int argc, char **argv) {
    int i=0, j, k, len, pid, afc, is_start;
    int in_video = 0;
 
    while(!feof(stdin)) {
        buf[i++] = getchar();
    }
    len = i-1;
 
    for (i=0; i<len; i+=188) {
#if 0
        for(j=0; j<188; j++)
            fprintf(stderr, "%02X ", buf[i+j]);
        fprintf(stderr, "\n");
#endif
 
        for(j=0; 1; j++) {
            int score = 0;
            for (k=1; k<188; k++) {
                if (headers[j].mask[k]) // count bits different
                    score += 8-popc8(headers[j].mask[k] & (buf[i+k] ^ headers[j].data[k]));
                else if (!headers[j].data[k])
                    break;  // zero header and mask, termination condition
            }
           
            double prob = score/(8.0 * k);        
            if (prob > headers[j].threshold) {
                for(k=0; k<188; k++) {
                    if (!(headers[j].mask[k] | headers[j].data[k]))  break;  // zero header and mask, termination condition
                    buf[i+k] = (buf[i+k] &~headers[j].mask[k]) | (headers[j].data[k] & headers[j].mask[k]);
 
                }
           
//                 for (k=0; k<188*8; k++) {
//                     if (GETBIT(headers[j].mask, k))
//                         PUTBIT(buf, 8*i + k, GETBIT(headers[j].data, k));
//                 }
                in_video = headers[j].flags;
//                 if (score < 15)
                fprintf(stderr, "SCORED %d %-4d (%f)\n", j, score, prob);
                break;
            }
            if(!headers[j].threshold)
                break;
        }
 
        is_start = buf[i+1] & 0x40;
        pid = ((buf[i+1]<<8) + buf[i+2]) & 0x1FFF;
        afc = (buf[i+3] >> 4) & 3;
 
        if (pid == 1000)
            in_video = 1;
       
        if (buf[i] != 0x47) {
            fprintf(stderr, "Fixing 0x%02X->0x47\n", buf[i]);
            buf[i] = 0x47;
        }
 
        // 1008, 4072 1001 1011
        if (in_video && pid != 0 && pid != 8191 && pid != 1000 && pid != 32 && pid != 64) {
            fprintf(stderr, "PID %d -> 1000\n", pid);
            pid = 1000;
        }
        if (pid == 1000 && !(afc&1)) {
            fprintf(stderr, "AFC %d -> %d\n", afc, afc|1);
            afc |= 1;
        }
        if (is_start && pid == 1000) {
            int j;
            for (j=0; j<188-3; j++) {
                if (buf[i+j] == 0 && buf[i+j+1] == 0 && buf[i+j+2] == 1)
                    break;
            }
            if (j == 188-3) {
                fprintf(stderr, "discarding is start\n");
                is_start = 0;
            }
        }
//without 0x47 fixing 3372
//without pid=1000 3356
//without afc|=1 3624
//ref 3728
//without is_start=0 2532
 
        buf[i+1] = (buf[i+1] & ~0x5F) + (pid>>8) + is_start;
        buf[i+2] = pid;
        buf[i+3] = (buf[i+3] & ~0x30) + (afc << 4);
    }
    for (i=0; i<len; i++)
        putchar(buf[i]);
 
    return 0;
}
